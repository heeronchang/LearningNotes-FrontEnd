# 继承和原型链

JavaScript 作为动态语言，本身并不提供 class 实现，ES6 中引入的 class 关键字只是语法糖，仍然是基于原型的。

当谈到继承时，JavaScript 只有一种结构：对象。每一个实例对象（object）都有一个私有属性（__proto__）指向它的原型对象（prototype）。
该原型对象也有一个自己的原型对象，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。

几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。

## 基于原型链的继承

JavaScript 对象有一个指向原型对象的链。当访问一个对象的属性时，它不仅仅在当前对象上查找，还会查找该对象的原型，以及该对象的原型的原型，
依次向上查找，直到找到一个名字匹配的属性或到达原型链的末尾。

ECMAScript 标准：someObject.[[Prototype]] 符合用于指向 someObject 的原型。
从 ES6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器访问。
等同于非 ECMAScript 标准但许多浏览器实现的属性 __proto__ 。

不要与构造函数 func 的 prototype 属性混淆。构造函数创建的实例对象的 [[Prototype]] 指向 func 的 prototype 属性。
Object.prototype 属性表示 Object 的原型对象。


## 原型链性能问题

在原型链上查找属性比较耗时，试图访问不存在的属性会遍历整个原型链。

### 要检查对象是否具有自定义的属性，而不是原型链上的某个属性

必须使用从 Object.prototype 继承的 hasOwnProperty 方法。该方法是 JavaScript 中处理属性并且不会遍历原型链的方法之一。（另一个是 Object.keys()）。
检查属性是否 undefined 还不够，该属性可能存在，但值恰好是 undefined。

### 扩展原生对象的原型

这种技术称为猴子补丁，并且会破坏封装，尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。
扩展内置原型的唯一理由是支持 JavaScript 引擎的新特性，如 Array.forEach 。

## prototype 和 Object.getPrototypeOf 

prototype 是用于类的，Object.getPrototypOf() 是用于实例的，两者功能一致。

## [继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)