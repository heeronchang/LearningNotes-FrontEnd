# JavaScript 正则表达式

JS 中正则表达式相较于等效的字符串运算，有显著的性能优势

## JS 中处理正则的方法有：
- regexp.exec
- regexp.test
- string.match
- string.replace
- string.search
- string.split

## 一枚栗子🌰
```JavaScript

  var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;

  var url = "http://www.ora.com:80/goodparts?q#fragment";
  var result = parse_url.exec(url);

  console.log(result); // ["http://www.ora.com:80/goodparts?q#fragment", "http", "//", "www.ora.com", "80", "goodparts", "q", "fragment", index: 0, input: "http://www.ora.com:80/goodparts?q#fragment", groups: undefined]

  var blanks = '                ';
  var names = ['url', 'schema', 'slash', 'host', 'port', 'path', 'query', 'hash'];

  for (let i = 0; i < names.length; i+= 1) {
    console.log(`${names[i]}: ${result[i]}`);
    // output
    /*
        url: http://www.ora.com:80/goodparts?q#fragment
        regex.html:27 schema: http
        regex.html:27 slash: //
        regex.html:27 host: www.ora.com
        regex.html:27 port: 80
        regex.html:27 path: goodparts
        regex.html:27 query: q
        regex.html:27 hash: fragment
      */
  }
  
```

### 解析：

`/^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/`

- `(?:([A-Za-z]+):)?`

匹配一个协议名，以 `:` 结尾的时候才能匹配。
`(?:...)` 表示一个非捕获型分组。
后缀 `?` 表示分组是可选的，它表示重复 0 次或 1 次。

`(...)` 表示一个捕获型分组。一个捕获型分组将复制它所匹配的文本，并将其放入 `result` 数组中。每个捕获型数组都将被指定一个编号。
第一个捕获型分组的编号是 1，所以该分组所匹配的文本拷贝将出现在 `result[1]` 中。

`[...]` 表示一个字符类。`A-Za-z` 表示26个大写字母和26个小写字母。`-` 连接符，表示范围从 A 到 Z。后缀 `+` 表示这个字符类将被匹配一次或多次。
最后的 `:` 将按字面文字进行匹配。

- `(\/{0, 3})` 捕获型分组。表示 `/` 将被匹配 0 到 3 次。
- `([0-9.\-A-Za-z]+)` 捕获型分组。表示匹配一次以上的由 字母、数字、`.` 、`-` 组成的字符串。
- `(?::(\d+))?` 非捕获型分组。匹配 前缀 `:` 和一个或多个数字组成的字符串。后缀 `?` 表示可选。
- `(?:\/([^?#]*))?` 非捕获型分组。匹配一个 `/` 开始，`[^?#]` 表示除了 `?` 和 `#` 的所有字符， `*` 表示这个字符匹配 0 或多次。后缀 `?` 表示可选。
- `(?:\?([^#]*))?` 非捕获型分组。以 `?` 开始，包含 0 或多个非 `#` 字符。后缀 `?` 表示可选。
- `(?:#(.*))?` 非捕获型分组。以 `#` 开始，任意多个除换行符外的字符。`.` 表示非换行符 `\n`。
- `$` 表示字符串的结束，之后不再有其它内容。

## 结构

### 正则表达式标志

- `g` 全局的（匹配多次，准确含义随方法而变）
- `i` 大小写不敏感
- `m` 多行（^ 和 $ 能匹配行结束符）

### 创建正则表达式的方法

- 使用一对斜杠 ‘/’ 包围正则表达式字面量
- 使用 RegExp 构造器
`let regexp = new RegExp("\"(?:\\.|[^\\\\\\\"])*\"", 'g'); `

RegExp 对象对属性：

| 属性 | 用法 |
| ---- | ---- |
| global | 如果标志 g 被使用，值为 true |
| ignoreCase | 如果标志 i 被使用，值为 true |
| lastIndex | 下一次 exec 匹配开始对索引。初始值 0 |
| multiline | 如果标志 m 被使用，值为 true |
| source | 正则表达式源代码文本 |

## 元素

### 正则表达式选择

一个正则表达式选择包含一个或多个正则表达式序列。这些序列被 “|” 分隔。如果这些序列中对任何一项符合匹配条件，那么这个选择就被匹配。
按顺序依次匹配这些序列项。
eg： `into.match(/in|int)` 将在 into 中匹配 in 不会匹配 int 因为 in 已经被匹配成功了。

### 正则表达式序列

一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，量词决定着该因子能被匹配几次。没有指定量词时，该因子默认被匹配一次。

### 正则表达式因子

一个正则表达式因子可以是一个字符、一个由圆括号包围的组，一个字符类，或者一个字符转义序列。
除了控制字符和特殊字符外，所有的字符都将被按照字面处理。

### 正则表达式转义

`\`

### 正则表达式分组

- 捕获型

一个捕获型分组是一个被圆括号包围的正则表达式选择。任何匹配这个分组的字符将被捕获。每个捕获型分组都指定了一个数字。
在正则表达式中第一捕获的（ 是分组 1 。第二个捕获的（ 是分组2 。

- 非捕获型

非捕获型分组有一个 `(?:` 前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配文本。这会有微弱的性能优势。非捕获型分组不会干扰捕获型分组的编号。

- 向前正向匹配（Positive lookahead）

向前正向匹配组有一个 `(?=` 前缀。它类似于非捕获型分组，但在这个组匹配后，文本将倒回到它开始的地方，实际上并不匹配任何东西。

- 向前负向匹配（Negative lookahead）

向前负向匹配分组有一个 `(?!` 前缀。它类似于向前正向匹配分组，但只有它匹配失败时它才进行匹配。

eg：
`<div>line1</div><br>`
比如我们要匹配这个语句中的`<`后面不是`<br>`的`<`：
正则这么写：`/<(?!br>)/` 。
如果只匹配后面为`br>` 的 `<`：
正则这么写：`/<(?=br>)/` 。

### 正则表达式类

正则表达式类是一种指定一组字符的便利方式。

`[aeiou]` `(?:a|e|i|o|u)`

### 正则表达式类转义

### 正则表达式量词

`/a{2}/`






